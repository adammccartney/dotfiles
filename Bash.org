* Bash config

** .profile

~~/.profile~: executed by the command interpreter for login shells.
This file is not read by bash(1), if ~~/.bash_profile~ or ~~/.bash_login~
exists.
see ~/usr/share/doc/bash/examples/startup-files~ for examples.
the files are located in the bash-doc package.

the default umask is set in /etc/profile; for setting the umask
for ssh logins, install and configure the libpam-umask package.
umask 022


#+begin_src shell :tangle ./bash/.profile
  # if running bash
  if [ -n "$BASH_VERSION" ]; then
      # include .bashrc if it exists
      if [ -f "$HOME/.bashrc" ]; then
      . "$HOME/.bashrc"
      fi
  fi
#+end_src


** Path variable 

Set the PATH environment variable to include my ~$HOME/bin~ directory.

#+begin_src shell :tangle ./bash/.profile
  if [ -d "$HOME/bin" ] ; then
      PATH="$HOME/bin:$PATH"
  fi
 
  if [ -d "$HOME/.local/bin" ] ; then
      PATH="$HOME/.local/bin:$PATH"
  fi
#+end_src



** .bashrc

#+begin_src shell :tangle ./bash/.bashrc
   # ~/.bashrc: executed by bash(1) for non-login shells.
  # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
  # for examples

  # If not running interactively, don't do anything
  case $- in
      ,*i*) ;;
        ,*) return;;
  esac

  # point to a populated terminfo database and explicitly set term
  export TERMINFO=/usr/share/terminfo
  export TERM=tmux-256color

  # don't put duplicate lines or lines starting with space in the history.
  # See bash(1) for more options
  HISTCONTROL=ignoreboth

  # append to the history file, don't overwrite it
  shopt -s histappend

  # for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
  HISTSIZE=1000
  HISTFILESIZE=2000

  # check the window size after each command and, if necessary,
  # update the values of LINES and COLUMNS.
  shopt -s checkwinsize

  # If set, the pattern "**" used in a pathname expansion context will
  # match all files and zero or more directories and subdirectories.
  #shopt -s globstar

  # make less more friendly for non-text input files, see lesspipe(1)
  [ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

  # set variable identifying the chroot you work in (used in the prompt below)
  if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
      debian_chroot=$(cat /etc/debian_chroot)
  fi

  # set a fancy prompt (non-color, unless we know we "want" color)
  case "$TERM" in
      xterm-color|*-256color) color_prompt=yes;;
  esac

  # Custom prompt that displays the time in upper left corner
  # along with a shortened path name on the left hand side, 
  # i.e. it only displays the name of the topmost path dir

  PS1="\[\033[s\033[0;0H\033[0;49m\033[K\033[1;33m\t\033[u\]<\u@\h \W>\$"


  # uncomment for a colored prompt, if the terminal has the capability; turned
  # off by default to not distract the user: the focus in a terminal window
  # should be on the output of commands, not on the prompt
  force_color_prompt=yes

  if [ -n "$force_color_prompt" ]; then
      if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
          # We have color support; assume it's compliant with Ecma-48
          # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
          # a case would tend to support setf rather than setaf.)
          color_prompt=yes
      else
          color_prompt=
      fi
  fi

  if [ "$color_prompt" = yes ]; then
      PS1="<\u@\h \W>\$"
      #PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
  else
      PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
  fi
  unset color_prompt force_color_prompt

  # If this is an xterm set the title to user@host:dir
  case "$TERM" in
  xterm*|rxvt*)
      PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
      ;;
  ,*)
      ;;
  esac

  # enable color support of ls and also add handy aliases
  if [ -x /usr/bin/dircolors ]; then
      test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
      alias ls='ls --color=auto'
      #alias dir='dir --color=auto'
      #alias vdir='vdir --color=auto'

      #alias grep='grep --color=auto'
      #alias fgrep='fgrep --color=auto'
      #alias egrep='egrep --color=auto'
  fi

  # colored GCC warnings and errors
  #export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

  # some more ls aliases
  #alias ll='ls -l'
  #alias la='ls -A'
  #alias l='ls -CF'

  # Alias definitions.
  # You may want to put all your additions into a separate file like
  # ~/.bash_aliases, instead of adding them here directly.
  # See /usr/share/doc/bash-doc/examples in the bash-doc package.

  if [ -f ~/.bash_aliases ]; then
      . ~/.bash_aliases
  fi


  # Function definitions.
  if [ -f ~/.bash_functions ]; then
    . ~/.bash_functions
  fi

  # Pvars.
  if [ -f ~/.bash_pvars ]; then
    . ~/.bash_pvars
  fi


  if [ -d "$HOME/bin" ] ; then
      PATH="HOME/bin:$PATH"
  fi

  # tmp var
  if [ -f ~/.bashvar ] ; then
      . ~/.bashvar
  fi

  # enable programmable completion features (you don't need to enable
  # this, if it's already enabled in /etc/bash.bashrc and /etc/profile
  # sources /etc/bash.bashrc).
  if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
      . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
      . /etc/bash_completion
    fi
  fi

  [ -f ~/.fzf.bash ] && source ~/.fzf.bash


  # set up environment variables for compiling from source in $HOME/.local
  export PATH=$HOME/.local/bin:$PATH
  export C_INCLUDE_PATH=$HOME/.local/include
  export CPLUS_INCLUDE_PATH=$HOME/.local/include
  export LIBRARY_PATH=$HOME/.local/lib
  export PKG_CONFIG_PATH=$HOME/.local/lib/pkgconfig

  # This tells the run time linker where to find
  # files installed in the home directory.
  # WARNING: may cause issues if an officially installed package is looking for
  # a library that is also installed on the system in a more holy manner.
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/:$HOME/.local/lib/

  # Set mail environment variable
  MAIL=/var/mail/adam && export MAIL

  # set realtime
  export SOUND_CARD_IRQ=169

  export PG_OF_PATH=$HOME/openFrameworks

  export PATH=$PATH:/sbin:/opt/ghc/bin:/opt/riscv/bin

  # temp variable for rehashing blog
  export OLDPOSTS=/media/websites/content/music
  export CONTENT=$HOME/Websites/admccartney/content
  export STATIC=$HOME/Websites/admccartney/static
  export NEWSHORTCODES=$HOME/Websites/admccartney/layouts/shortcodes
  export NEWSOUNDS=$HOME/Websites/admccartney/static/sounds

  source "$HOME/.cargo/env"

  # Remote server variable
  export REMOTE1=206.189.52.96
  . "$HOME/.cargo/env"

  # use vim keybindings
  set -o vi
  [ -f "/home/adam/.ghcup/env" ] && source "/home/adam/.ghcup/env" # ghcup-env

  # git tools
  . ~/git-completion.bash
  . ~/git-prompt.sh
  export GIT_PS1_SHOWDIRTYSTATE=1

  PS1="\[\033[s\033[0;0H\033[0;49m\033[K\033[1;33m\t\033[u\]<\u@\h \W>\$"
  export PS1='<\u@\h \W>$(__git_ps1 " (%s)")\$'

  # virtualenv wrapper
  export WORKON_HOME=$HOME/.virtualenvs
  export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
  export VIRTUALENVWRAPPER_VIRTUALENV_ARGS=' -p /usr/bin/python3 '
  export PROJECT_HOME=$HOME/.virtualenvs/venvs
  source /usr/local/bin/virtualenvwrapper.sh

  # source the cht.sh bashcompletion file
  if [ -f ~/.bash.d/cht.sh ] ; then
      . ~/.bash.d/cht.sh
  fi

  # swap the control and caps key
  swap_ctrl_caps

  #+end_src
  

** bash functions

Swap the control and caps key (avoid emacs trench pinky)

#+begin_src shell :tangle ./bash/.bash_functions

    # ~/.bash_functions: collection of command line functions
    # useage: source via ~/.bashrc at runtime
  
  function swap_ctrl_caps () {
        XKBOPTIONS="ctrl:swapcaps"
        if command /usr/bin/gsettings &> /dev/null; then
            /usr/bin/gsettings set org.gnome.desktop.input-sources xkb-options "['caps:ctrl_modifier']"
        fi
        if command /usr/bin/setxbmap &> /dev/null; then
            /usr/bin/setxkbmap -option $XKBOPTIONS
        fi
      }


#+end_src

Some random testy functions

#+begin_src shell :tangle ./bash/.bash_functions
  # Functions

  ds () {
      echo "Disk Space Utilization For $HOSTNAME"
      df -h
  }

  hs () {
      echo "Home Space Utilzation For $USER"
      du -sh /home/*
  }
#+end_src

That time Bob Nystrom wrote a great book and we needed a tool to extract the binary of
the cool language he developed.

#+begin_src shell :tangle ./bash/.bash_functions
  extractLoxBin () {
      DISTDIR=/home/adam/.local/src/jlox/build/distributions
      TARGETDIR=${DISTDIR}
      tar -xf "${DISTDIR}/jlox.tar" -C "${TARGETDIR}"
  }
#+end_src


I think I used to use this for renaming files after cloning C projects,
or any other time I needed to recursively rename files.

#+begin_src shell :tangle ./bash/.bash_functions
  function renameFilesRecursively () {

    SEARCH_PATH="$1"
    SEARCH="$2"
    REPLACE="$3"

    find ${SEARCH_PATH} -type f -name "*${SEARCH}*" | while read FILENAME ; do
        NEW_FILENAME="$(echo ${FILENAME} | sed -e "s/${SEARCH}/${REPLACE}/g")";
        mv "${FILENAME}" "${NEW_FILENAME}";
    done

  }
#+end_src


This is for spawning a new tmux namespace with a split configuration that is nice for
your face.

#+begin_src shell :tangle ./bash/.bash_functions
  function tmux_ns () {
      SESNAME="$1"
      tmux new-session -s $SESNAME -d
      tmux split-window -h
      tmux split-window -v
      tmux -2 attach-session -d 
  }
#+end_src


Get the ip of a docker container, assumes that docker is running on your system (poor you)
#+begin_src shell :tangle ./bash/.bash_functions
  function containerip () {
     sudo docker inspect −−format '{{ .NetworkSettings.IPAddress }}' "$@"
  }
#+end_src


Creates a python3.8 virtualenvironment and plonks it in ~/.virtualenvs future me will just
use virtual machines
#+begin_src shell :tangle ./bash/.bash_functions
  function make_py3.8venv () {
      NAME="$1"
      #python3.8 -m venv "~/.virtualenvs/${NAME}"
      echo "~/.virtualenvs/${NAME}"
  }
#+end_src


Handy dump of all currently LISTENing sockets on a system (will run as sudo)
#+begin_src shell :tangle ./bash/.bash_functions
  # list all ports currently listening
  get_listening_ports () {
      sudo lsof -i -P -n | grep LISTEN 
  }
#+end_src


I think these might have been a bunch of functions that were useful for the System Programming for Linux Containers course.
Or possibly the OSTEP book... can't remember.
#+begin_src shell :tangle ./bash/.bash_functions
  function installed {
      cmd=$(command -v "${1}")

      [[ -n "${cmd}" ]] && [[ -f "${cmd}" ]]
      return ${?}
  }

  function die {
      >&2 echo "Fatal: ${@}"
      exit 1
  }


  function wi { 
      test -n "$1" && stat --printf "%F\n" $1
      }


  function size {
      t=0
      test -d "$1" && for n in $(find $1 \
      -type f -name '*.py' -print | \
      xargs stat --printf "%s "); do ((t+=n)); done; echo $t; 
  }

#+end_src

Leverages a cool api to show the current weather in your terminal (I mean, hopefully there is no actual
weather happening in your terminal) outside I mean, in the environment where you run the computer that
houses your terminal.
#+begin_src shell :tangle ./bash/.bash_functions
  function weather { 
      curl -s --connect-timeout 3 -m 5 http://wttr.in/$1 
  }
#+end_src

Elastic search (what and why and how and who is elastic search I hear you ask, I also have no idea,
I think it's an index for someone who hasn't heard about C.
#+begin_src shell :tangle ./bash/.bash_functions
  # Elastic search functions
  if [ -f ~/.elastic_fun ]; then
      . ~/.elastic_fun
  fi
#+end_src


** repltings with inotifywait

*** C projects

#+begin_src shell :tangle ./bash/.bash_functions
  function makeonchange () {
      while inotifywait -q . ; do echo -e '\n\n'; make; done
  }
#+end_src


*** Python

**** Sphinx docs

Here are a couple of helpers for running with 


#+begin_src shell :tangle ./bash/.bash_functions
  function make_html_onchange () {
      # Run from the 'project/docs' directory
      while inotifywait -q ./source ; do echo -e '\n\n'; make html; done
      # Watch the source directory, if there are any changes, remake the docs.
      }

  function serve_html_docs () {
      # Run from the 'project/docs' directory
      cd ./build/html && python3 -m http.server
      # Serve the html docs built by sphinx
  }
#+end_src

*** Pytest

#+begin_src shell :tangle ./bash/.bash_functions
    function pytestonchange () {
        TESTS=$1
        while inotifywait -q ${TESTS};
        do
            echo -e '\n\n';
            pytest ${TESTS} -v;
        done
    }
#+end_src


Haul that mail truck in 

#+begin_src shell :tangle ./bash/.bash_functions
  getmail () {
      mbsync -a
  }

#+end_src

** Backup functions

A selection of wrappers for calling rsync in a bunch of ways that are generally useful for my particular situation.


*** Backup home
rsync allows for the specification of paths to be excluded from the backup
The trick with rsync is to use relative paths for the files/directories to be excluded
#+begin_src conf :tangle ~/backup_excludes.txt
  /.android
  /.cache   
  /Code
  /.local/src
  /.virtualenvs
  /snap
  /openFrameworks
  /node_modules
  /dotfiles
  /.config
#+end_src

We want to copy everything in $HOME, excluding stuff that is anyway in version control, anything related to cache,
and any sort of temp or environment files.
#+begin_src shell :tangle ./bash/.bash_functions
    function backup_home () {
        # WARNING: assumes that you are running from home!
        BACKUP_PATH=$1
        EXCLUDES_PATH=$2
        rsync -raP  --exclude="/.*" --exclude-from=$EXCLUDES_PATH --include="/.ssh" --include="/.password-store" ./ $BACKUP_PATH
  }

  function backup () {
      export CURRENTDATE=`date +"%b%d%Y"`
      export BACKUPTYPE="diza"

      if [ ! -d "/media/adam/ADB/backup/$BACKUPTYPE/$CURRENTDATE/" ]; then
          mkdir -p /media/adam/ADB/backup/$BACKUPTYPE/$CURRENTDATE
          export BACKUP_DIR="/media/adam/ADB/backup/$BACKUPTYPE/$CURRENTDATE"
      fi

      EXCLUDES_LIST="$HOME/backup_excludes.txt"

      backup_home $BACKUP_DIR $EXCLUDES_LIST
  }
  #+end_src

  

* Go setup

There seems to have been a bit of confusion around how to set up a number of
variables typically used in creating a go workflow. Might well have been my
own misunderstaning of the various docs online the following [[https://go.dev/doc/gopath_code][guide to writing code with gopath]]
seems to suggest the following solution as of August 2022. This bash config snippet
has been used on a machine where the install site of the [[https://go.dev/doc/install][go binary]] is "/usr/local/go".

#+begin_src shell :tangle ./bash/.bashrc
  # Gopath
  # add the go binary to path
  export PATH=$PATH:/usr/local/go/bin
  export GOPATH=$HOME/.local/go
  # add the GOPATH/bin to PATH
  export PATH=$PATH:$(go env GOPATH)/bin
#+end_src

** .bash_aliases

Bunch of aliases used for alter egos.

#+begin_src shell :tangle ./bash/.bash_aliases
  ## virtualenv alias
  #alias sv="source env/bin/activate"
  #
  ## IPython in a virtual env
  #alias ipy="python -c 'import IPython; IPython.terminal.ipapp.launch_new_instance()'"

  ## frog virtual env alias (for Scores/rill)
  #alias frogsv="source ~/Scores/frog/env/bin/activate"

  # plot virtual env 
  alias plot="source ~/.virtualenvs/plot/bin/activate"

  # chi virtual env (for Django webversion of iChing)
  alias chi="source ~/.virtualenvs/chi/bin/activate"

  # ni virtual env (for abjad scores)
  alias ni="source ~/.virtualenvs/ni/bin/activate"

  # plot virtual env (for learning & iChing)
  alias tt="source ~/.virtualenvs/tt/bin/activate"

  # call an iChing reading
  alias iching="python3 ~/Code/iChing/iChing/build/iching.py"

  # fl venv
  alias fl="source ~/.virtualenvs/fl/bin/activate"

  # jlox
  alias jlox="~/.local/src/jlox/build/distributions/jlox/bin/jlox"

  # python3.8
  alias py3.8="/usr/local/bin/python3.8"

  # python 3.10
  alias py310="/usr/local/bin/python3.10"

  # wagtail python 3.8
  alias wtpy38="source ~/.virtualenvs/wtpy38/bin/activate"

  # django: postgres python38
  alias pstgrsql="source ~/.virtualenvs/postgresql/bin/activate"

  # neovim
  alias vim="$(which nvim)"
 
  # psql alias (hand compiled version on unix has the side effect of trying to
  # connect with another port. To get around this, we have to connect using the
  # -h flag and the socket that is specified by the debian system
  alias psql="psql -h /var/run/postgresql"

  alias DIZA="192.168.0.193"

  alias tlog="$HOME/Documents/traininglogs/training22.md"

  alias actenv="source venv/bin/activate"

  alias train="source $HOME/bin/train"

  alias !P="PS1='# '"
#+end_src
